#' @title Read ESIOS CSVs or RDAs and transform into functional-data (\code{fdata}) objects
#' 
#' @description Read ESIOS CSVs or RDAs and transform into functional-data (fdata) objects,
#' handling daylight saving time anomalies by smoothing missing or duplicated intervals.
#'
#' @param var_names Character vector of variable names (e.g. "Solar_PV_119").
#' @param years Integer vector of years to process.
#' @param resolution "hour" or "min".
#' @param input_dir Directory with CSVs or RDAs.
#' @param output_dir Where to save generated RDAs; created if missing.
#' @param mode "csv" or "rda".
#' @param verbose Logical.
#' @return A list of class c("ldata","list") with \code{fdata} objects.
#' @importFrom utils read.csv2
#' @importFrom stats xtabs
#' @importFrom lubridate ymd_hms yday hour minute
#' @importFrom fda.usc fdata
#' @importFrom dplyr mutate
#' @export
esios2fdata <- function(var_names, years, resolution = c("hour","min"),
                        input_dir, output_dir = NULL, mode = c("csv","rda"), 
                        verbose=FALSE) {
  
  resolution <- match.arg(resolution)
  suffix     <- if(resolution=="min") "m" else "h"
  mode       <- match.arg(mode)
  if (!is.null(output_dir) && !dir.exists(output_dir)) {
    dir.create(output_dir, recursive = TRUE)
  }
  
  smooth_mat <- function(mat, target_cols) {
    n <- ncol(mat)
    pos <- if(resolution=="min") 13 else 3
    # insert columns if faltan
    while(n < target_cols) {
      lo <- mat[,pos-1]; hi <- mat[,pos]
      interp <- (lo + hi)/2
      mat <- cbind(mat[,1:(pos-1),drop=FALSE], interp, mat[,pos:ncol(mat),drop=FALSE])
      n <- ncol(mat)
    }
    # remove columns if sobran
    while(n > target_cols) {
      mat[,pos] <- (mat[,pos] + mat[,pos+1])/2
      mat <- mat[,-(pos+1), drop=FALSE]
      n <- ncol(mat)
    }
    mat
  }
  
  out <- list()
  for(var in var_names) {
    if(verbose) message("Processing ", var)
    for(yr in years) {
      if(verbose) message(" Year ", yr)
      name_base <- sprintf("%s_%s%04d", var, suffix, yr)
      
      ## 1) Lectura segura del fichero
      if(mode == "csv") {
        fpath <- file.path(input_dir, paste0(name_base, ".csv"))
        df_raw <- tryCatch(
          read.csv2(fpath, stringsAsFactors=FALSE),
          error = function(e) {
            warning(sprintf(
              "Variable '%s': file '%s' not found; skipping this year.",
              var, basename(fpath)
            ))
            return(NULL)
          }
        )
        if (is.null(df_raw)) next
        
        df <- df_raw %>%
          mutate(time = ymd_hms(
            ifelse(grepl("^\\d{2}/\\d{2}/\\d{4}", instant),
                   as.character(as.POSIXct(instant, format="%d/%m/%Y %H:%M", tz="Europe/Madrid")),
                   instant), tz="Europe/Madrid"))
        df_proc <- df %>% mutate(
          yday     = yday(time),
          hour     = hour(time),
          minute   = minute(time),
          interval = if(resolution=="min") hour*6 + minute/10 + 1 else hour,
          value    = as.numeric(gsub(",", ".", val))
        )
        
      } else {
        rpath <- file.path(input_dir, paste0(name_base, ".rda"))
        rdaload <- tryCatch(
          load(rpath),
          error = function(e) {
            warning(sprintf(
              "Variable '%s': file '%s' not found; skipping this year.",
              var, basename(rpath)
            ))
            return(NULL)
          }
        )
        if (is.null(rdaload)) next
        fd <- get(rdaload)
        dates <- seq(as.Date(sprintf("%04d-01-01", yr)), by="day", length.out=nrow(fd$data))
        if(resolution=="min") {
          times <- do.call(c, lapply(dates, function(d) seq(as.POSIXct(d), by="10 min", length.out=144)))
        } else {
          times <- do.call(c, lapply(dates, function(d) seq(as.POSIXct(d), by="1 hour", length.out=24)))
        }
        df_proc <- data.frame(time=times, value=as.numeric(t(fd$data))) %>%
          mutate(
            yday     = yday(time),
            hour     = hour(time),
            minute   = minute(time),
            interval = if(resolution=="min") hour*6 + minute/10 + 1 else hour
          )
      }
      
      ## 2) Construcción de la matriz
      if(resolution=="min") {
        mat <- xtabs(value ~ yday + interval, data=df_proc)
        target_cols <- 144
      } else {
        mat <- xtabs(value ~ yday + hour, data=df_proc)
        target_cols <- 24
      }
      
      ## 3) Suavizado DST
      mat_sm <- smooth_mat(mat, target_cols)
      
      ## 4) Creación de fdata
      argvals <- if(resolution=="min") seq(0, 143)/144*24 else seq(0.5, 23.5, length = 24)
      fdobj <- fda.usc::fdata(mat_sm, argvals,
                              names=list(main=var,
                                         xlab = if(resolution=="min") "10-min intervals" else "Hours",
                                         ylab = "MW"))
      
      ## 5) Guardado y almacenamiento
      if (!is.null(output_dir)) {
        save(fdobj, file = file.path(output_dir, paste0(name_base, ".rda")))
      }
      out[[name_base]] <- fdobj
    }
  }
  
  class(out) <- c("ldata","list")
  invisible(out)
}


