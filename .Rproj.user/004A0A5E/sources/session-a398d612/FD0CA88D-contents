#' @encoding UTF-8
#' @title Download ESIOS time-series and save as CSV (with robust splitting for large ranges)
#'
#' @description
#'   \code{esios2csv} retrieves raw ESIOS indicators from Spain's API and writes
#'   individual CSV files per variable and year, named <var_name><suffix><year>.csv.
#'   Supported resolutions: "1min","5min","10min","15min","30min","hour","1hour".
#'   It enforces the \code{instant} column in "YYYY-MM-DD HH:MM:SS" format (Europe/Madrid),
#'   handles large date ranges by splitting on HTTP 504, and reports warnings on errors.
#'
#' @param var_names   Character vector of indicators in "ShortName_ID" format.
#' @param years       Integer vector of years to download, e.g. \code{2023:2024}.
#' @param api_key     String: your ESIOS API key.
#' @param resolution  Character: one of "1min","5min","10min","15min","30min","hour","1hour".
#' @param output_dir  Directory where CSV files will be saved (created if needed).
#' @param verbose     Logical; if TRUE, prints progress messages.
#' @param encoding    Encoding used to read JSON (default "UTF-8").
#'
#' @return Invisibly, character vector of saved file paths.
#' @export
esios2csv <- function(var_names, years, api_key,
                      resolution = c("1min","5min","10min","15min","30min","hour","1hour"),
                      output_dir, verbose = FALSE, encoding = "UTF-8") {
  resolution <- match.arg(resolution)
  tz <- "Europe/Madrid"
  
  suffix_map <- c(
    "1min"  = "1m",  "5min"  = "5m",  "10min" = "10m",
    "15min" = "15m", "30min" = "30m", "hour"  = "h",  "1hour" = "h"
  )
  trunc_map <- c(
    "1min"  = "minute",       "5min"  = "five_minutes",
    "10min" = "ten_minutes",  "15min" = "fifteen_minutes",
    "30min" = "thirty_minutes","hour"  = "hour",         "1hour" = "hour"
  )
  suffix     <- suffix_map[[resolution]]
  time_trunc <- trunc_map[[resolution]]
  if (!dir.exists(output_dir)) dir.create(output_dir, recursive = TRUE)
  
  # Helper: recursively fetch values, splitting on 504
  fetch_range <- function(var_id, s_dt, e_dt) {
    start_iso <- format(lubridate::with_tz(s_dt, "UTC"), "%Y-%m-%dT%H:%M:%SZ")
    end_iso   <- format(lubridate::with_tz(e_dt, "UTC"), "%Y-%m-%dT%H:%M:%SZ")
    url <- sprintf(
      "https://api.esios.ree.es/indicators/%d?start_date=%s&end_date=%s&time_trunc=%s&locale=es",
      var_id, start_iso, end_iso, time_trunc
    )
    resp <- tryCatch(
      httr::GET(url,
                httr::add_headers(
                  Accept      = "application/json; application/vnd.esios-api-v1+json",
                  `Content-Type` = "application/json",
                  `x-api-key` = api_key
                ),
                httr::timeout(120)),
      error = function(e) e
    )
    if (inherits(resp, "error")) return(NULL)
    code <- httr::status_code(resp)
    if (code == 504) {
      # split interval
      mids <- s_dt + (e_dt - s_dt) / 2
      df1 <- fetch_range(var_id, s_dt, mids)
      df2 <- fetch_range(var_id, mids + lubridate::seconds(1), e_dt)
      if (is.null(df1) && is.null(df2)) return(NULL)
      return(rbind(df1, df2))
    }
    if (code != 200) return(NULL)
    parsed <- tryCatch(
      jsonlite::fromJSON(httr::content(resp, "text", encoding = encoding), simplifyDataFrame = TRUE),
      error = function(e) NULL
    )
    if (is.null(parsed$indicator$values)) return(NULL)
    as.data.frame(parsed$indicator$values, stringsAsFactors = FALSE)
  }
  
  saved <- character()
  for (var_name in var_names) {
    var_id <- as.integer(sub(".*_(\\d+)$", "\\1", var_name))
    if (is.na(var_id)) {
      warning(sprintf("Invalid var '%s' (cannot extract ID); skipping.", var_name))
      next
    }
    for (yr in years) {
      if (verbose) message(sprintf("Processing '%s' (ID=%d) for %d...", var_name, var_id, yr))
      s_dt <- as.POSIXct(sprintf("%d-01-01 00:00:00", yr), tz = tz)
      e_dt <- as.POSIXct(sprintf("%d-12-31 23:59:59", yr), tz = tz)
      df_raw <- fetch_range(var_id, s_dt, e_dt)
      if (is.null(df_raw) || nrow(df_raw)==0) {
        warning(sprintf("'%s' has no %s data for %d; skipping.", var_name, resolution, yr)); next
      }
      # ensure datetime
      if (!"datetime" %in% names(df_raw) && "date" %in% names(df_raw)) {
        df_raw$datetime <- paste0(df_raw$date, "T00:00:00Z")
      }
      # parse timestamps
      tm <- tryCatch(
        lubridate::ymd_hms(df_raw$datetime, tz = "UTC") %>% lubridate::with_tz(tz),
        error = function(e) NULL
      )
      if (is.null(tm)) { warning(sprintf("'%s': timestamp parse error; skipping.")); next }
      
      df_out <- df_raw %>%
        dplyr::mutate(
          instant = format(tm, "%Y-%m-%d %H:%M:%S")
        ) %>%
        dplyr::transmute(
          instant = instant,
          val     = value,
          geocode = if ("geocode" %in% names(df_raw)) geocode else NA_integer_,
          geolabel = if ("geolabel" %in% names(df_raw)) geolabel else NA_character_
        )
      fn <- file.path(output_dir, sprintf("%s_%s%04d.csv", var_name, suffix, yr))
      tryCatch({
        write.csv2(df_out, fn, row.names = FALSE, quote = TRUE)
        saved <<- c(saved, fn)
        if (verbose) message(sprintf("  Saved %s (%d rows)", basename(fn), nrow(df_out)))
      }, error = function(e) warning(sprintf("Failed to save '%s': %s", fn, e$message)))
    }
  }
  invisible(saved)
}
#' 
#' 
#' #' @encoding UTF-8
#' #' @title Download ESIOS time-series and save as CSV (with multi-resolution support)
#' #'
#' #' @description
#' #'   \code{esios2csv} retrieves raw ESIOS indicators from Spain's API and writes
#' #'   individual CSV files per variable and year, named <var_name><suffix><year>.csv.
#' #'   Supported resolutions: "1min", "5min", "10min", "15min", "30min", "hour", "1hour".
#' #'   It enforces the \code{instant} column in "YYYY-MM-DD HH:MM:SS" format (Europe/Madrid)
#' #'   and handles API or parsing errors with warnings.
#' #'
#' #' @param var_names   Character vector of indicators in "ShortName_ID" format.
#' #' @param years       Integer vector of years to download, e.g. \code{2023:2024}.
#' #' @param api_key     String: your ESIOS API key.
#' #' @param resolution  Character: one of "1min","5min","10min","15min","30min","hour","1hour".
#' #' @param output_dir  Directory where CSV files will be saved (created if needed).
#' #' @param verbose     Logical; if TRUE, prints progress messages.
#' #' @param encoding    Encoding used to read JSON (default "UTF-8").
#' #'
#' #' @return Invisibly, character vector of saved file paths.
#' #' @export
#' esios2csv <- function(var_names, years, api_key,
#'                       resolution = c("1min","5min","10min","15min","30min","hour","1hour"),
#'                       output_dir, verbose = FALSE, encoding = "UTF-8") {
#'   resolution <- match.arg(resolution)
#'   tz <- "Europe/Madrid"
#'   
#'   # Map resolution to file suffix and API time_trunc
#'   suffix_map <- c(
#'     "1min"  = "1m",  "5min"  = "5m",  "10min" = "10m",
#'     "15min" = "15m", "30min" = "30m", "hour"  = "h",  "1hour" = "h"
#'   )
#'   trunc_map <- c(
#'     "1min"  = "minute",       "5min"  = "five_minutes",
#'     "10min" = "ten_minutes",  "15min" = "fifteen_minutes",
#'     "30min" = "thirty_minutes","hour"  = "hour",         "1hour" = "hour"
#'   )
#'   
#'   suffix     <- suffix_map[[resolution]]
#'   time_trunc <- trunc_map[[resolution]]
#'   if (!dir.exists(output_dir)) dir.create(output_dir, recursive = TRUE)
#'   
#'   saved <- character()
#'   for (var_name in var_names) {
#'     var_id <- as.integer(sub(".*_(\\d+)$", "\\1", var_name))
#'     if (is.na(var_id)) {
#'       warning(sprintf("Invalid var '%s' (cannot extract ID); skipping.", var_name))
#'       next
#'     }
#'     
#'     for (yr in years) {
#'       if (verbose) message(sprintf("Processing '%s' (ID=%d) for %d...", var_name, var_id, yr))
#'       start_dt <- as.POSIXct(sprintf("%d-01-01 00:00:00", yr), tz = tz)
#'       end_dt   <- as.POSIXct(sprintf("%d-12-31 23:59:59", yr), tz = tz)
#'       
#'       # Fetch data
#'       res <- tryCatch(
#'         httr::GET(
#'           sprintf(
#'             "https://api.esios.ree.es/indicators/%d?start_date=%s&end_date=%s&time_trunc=%s&locale=es",
#'             var_id,
#'             format(lubridate::with_tz(start_dt, "UTC"), "%Y-%m-%dT%H:%M:%SZ"),
#'             format(lubridate::with_tz(end_dt,   "UTC"), "%Y-%m-%dT%H:%M:%SZ"),
#'             time_trunc
#'           ),
#'           httr::add_headers(
#'             Accept      = "application/json; application/vnd.esios-api-v1+json",
#'             `Content-Type` = "application/json",
#'             `x-api-key` = api_key
#'           ),
#'           httr::timeout(120)
#'         ),
#'         error = function(e) {
#'           warning(sprintf("'%s' @ %d: request failed (%s); skipping.", var_name, yr, e$message))
#'           NULL
#'         }
#'       )
#'       if (is.null(res) || httr::status_code(res) != 200) next
#'       
#'       p <- tryCatch(
#'         jsonlite::fromJSON(httr::content(res, "text", encoding = encoding), simplifyDataFrame = TRUE),
#'         error = function(e) {
#'           warning(sprintf("'%s' @ %d: invalid JSON; skipping.", var_name, yr)); NULL
#'         }
#'       )
#'       vals <- p$indicator$values
#'       if (!is.data.frame(vals) || nrow(vals) == 0) {
#'         warning(sprintf("'%s' @ %d: no data; skipping.", var_name, yr)); next
#'       }
#'       
#'       df_raw <- as.data.frame(vals, stringsAsFactors = FALSE)
#'       if (!"datetime" %in% names(df_raw) && "date" %in% names(df_raw)) {
#'         df_raw$datetime <- paste0(df_raw$date, "T00:00:00Z")
#'       }
#'       
#'       tm <- tryCatch(
#'         lubridate::ymd_hms(df_raw$datetime, tz = "UTC") %>% lubridate::with_tz(tz),
#'         error = function(e) NULL
#'       )
#'       if (is.null(tm)) { warning(sprintf("'%s' @ %d: cannot parse times; skipping.", var_name, yr)); next }
#'       
#'       # Check alignment
#'       if (resolution == "hour" || resolution == "1hour") {
#'         if (any(lubridate::minute(tm) != 0 | lubridate::second(tm) != 0)) {
#'           warning(sprintf("'%s' has no hourly data for %d; skipping.", var_name, yr)); next
#'         }
#'       } else {
#'         exp_secs <- c(
#'           "1min"  = 60,     "5min"  = 5*60,
#'           "10min" = 10*60,   "15min" = 15*60,
#'           "30min" = 30*60
#'         )
#'         diffs <- as.numeric(diff(sort(unique(tm))), units = "secs")
#'         if (!any(abs(diffs - exp_secs[resolution]) < 1e-6)) {
#'           warning(sprintf("'%s' has no %s data for %d; skipping.", var_name, resolution, yr)); next
#'         }
#'       }
#'       
#'       # Build output dataframe
#'       df_out <- df_raw %>%
#'         dplyr::mutate(
#'           tm      = tm,
#'           instant = format(tm, "%Y-%m-%d %H:%M:%S")
#'         ) %>%
#'         dplyr::transmute(
#'           instant  = instant,
#'           val       = value,
#'           geocode   = if ("geocode" %in% names(df_raw)) geocode else NA_integer_,
#'           geolabel  = if ("geolabel" %in% names(df_raw)) geolabel else NA_character_
#'         )
#'       
#'       fn <- file.path(output_dir, sprintf("%s_%s%04d.csv", var_name, suffix, yr))
#'       tryCatch({
#'         write.csv2(df_out, fn, row.names = FALSE, quote = TRUE)
#'         saved <<- c(saved, fn)
#'         if (verbose) message(sprintf("  Saved %s (%d rows)", basename(fn), nrow(df_out)))
#'       }, error = function(e) {
#'         warning(sprintf("Failed to save '%s': %s", fn, e$message))
#'       })
#'     }
#'   }
#'   invisible(saved)
#' }
#' 
#' 

#' 
#' #' @title Download ESIOS time-series and save as CSV
#' #'
#' #' @description
#' #' Download raw ESIOS indicator time-series from Spain's API and save a single CSV file per variable and year.
#' #'
#' #' @param var_names Character vector of indicators in "ShortName_ID" format (e.g. c("Wind_551", "Solar_PV_119")).
#' #' @param years Integer vector of years to download (e.g. 2023:2024).
#' #' @param api_key String: your personal ESIOS API key.
#' #' @param resolution Character: one of "1min", "5min", "10min", "15min", "30min", "1hour", "4hour", "1day".
#' #'   Determines the time aggregation requested from the API.
#' #' @param output_dir Directory where CSV files will be saved (created if needed).
#' #' @param verbose Logical; if TRUE prints progress messages (default FALSE).
#' #' @param encoding Character: JSON encoding for API responses (default "UTF-8").
#' #'
#' #' @details
#' #' Internally, the function splits each year into monthly intervals to avoid timeouts,
#' #' but it writes a single CSV per variable and year, named <var_name>_<resolution>_<year>.csv.
#' #'
#' #' @return Invisibly returns NULL. CSV files are written to disk.
#' #'
#' #' @importFrom httr GET add_headers timeout status_code content
#' #' @importFrom jsonlite fromJSON
#' #' @importFrom lubridate ymd ymd_hms with_tz days seconds
#' #' @importFrom dplyr bind_rows mutate transmute
#' #' @export
#' esios2csv <- function(var_names,
#'                       years,
#'                       api_key,
#'                       resolution = c("1min","5min","10min","15min","30min","1hour","4hour","1day"),
#'                       output_dir,
#'                       verbose = FALSE,
#'                       encoding = "UTF-8") {
#'   resolution <- match.arg(resolution)
#'   if (!dir.exists(output_dir)) dir.create(output_dir, recursive = TRUE)
#'   
#'   # Mapping resolution to API time_trunc parameter and expected interval
#'   trunc_map <- list(
#'     "1min"   = list(param="minute",        secs=60),
#'     "5min"   = list(param="five_minutes",  secs=5*60),
#'     "10min"  = list(param="ten_minutes",   secs=10*60),
#'     "15min"  = list(param="fifteen_minutes", secs=15*60),
#'     "30min"  = list(param="thirty_minutes", secs=30*60),
#'     "1hour"  = list(param="hour",          secs=3600),
#'     "4hour"  = list(param="four_hours",    secs=4*3600),
#'     "1day"   = list(param="day",           secs=24*3600)
#'   )
#'   
#'   to_iso_utc <- function(dt) format(with_tz(dt, "UTC"), "%Y-%m-%dT%H:%M:%SZ")
#'   
#'   for (var in var_names) {
#'     if (verbose) message("Processing ", var, " @ ", resolution)
#'     if (!grepl("_\\d+$", var)) stop("'", var, "' must follow '<name>_<id>' format.")
#'     vid <- as.integer(sub(".*_(\\d+)$", "\\1", var))
#'     param <- trunc_map[[resolution]]$param
#'     ok <- FALSE
#'     saved <- character()
#'     
#'     for (yr in years) {
#'       if (verbose) message(" Year ", yr)
#'       # split year by month to avoid large requests
#'       for (month in 1:12) {
#'         start_dt <- as.POSIXct(sprintf("%04d-%02d-01 00:00:00", yr, month), tz="Europe/Madrid")
#'         end_dt   <- start_dt + months(1) - seconds(1)
#'         if (month == 12) end_dt <- as.POSIXct(sprintf("%04d-12-31 23:59:59", yr), tz="Europe/Madrid")
#'         
#'         resp <- suppressWarnings(suppressMessages(
#'           httr::GET(
#'             sprintf("https://api.esios.ree.es/indicators/%d?start_date=%s&end_date=%s&time_trunc=%s&locale=es",
#'                     vid, to_iso_utc(start_dt), to_iso_utc(end_dt), param),
#'             httr::add_headers(
#'               Accept = "application/json; application/vnd.esios-api-v1+json",
#'               `x-api-key` = api_key
#'             ),
#'             httr::timeout(60)
#'           )
#'         ))
#'         
#'         if (httr::status_code(resp) == 504) {
#'           warning("HTTP 504 splitting month ", month, " for year ", yr)
#'           next
#'         } else if (httr::status_code(resp) != 200) {
#'           warning(sprintf("HTTP %d for %s @ %d", httr::status_code(resp), var, yr))
#'           next
#'         }
#'         
#'         raw <- jsonlite::fromJSON(httr::content(resp, "text", encoding=encoding), simplifyDataFrame=TRUE)$indicator$values
#'         if (nrow(raw) == 0) next
#'         ok <- TRUE
#'         
#'         # prepare output df
#'         df <- as.data.frame(raw, stringsAsFactors=FALSE)
#'         if (!"datetime" %in% names(df) && "date" %in% names(df)) {
#'           df$datetime <- paste0(df$date, "T00:00:00Z")
#'         }
#'         df$instant <- df$datetime
#'         df <- df %>%
#'           dplyr::mutate(
#'             instant = format(as.POSIXct(instant, format="%Y-%m-%dT%H:%M:%OSZ", tz="UTC"), "%Y-%m-%d %H:%M:%S") %>%
#'               with_tz("Europe/Madrid")
#'           ) %>%
#'           dplyr::transmute(
#'             instant,
#'             value   = value,
#'             geocode = if ("geocode" %in% names(df)) geocode else NA_integer_,
#'             geolabel= if ("geolabel"%in% names(df)) geolabel else NA_character_
#'           )
#'         
#'         # accumulate
#'         if (!exists("df_year", inherits=FALSE)) df_year <- df else df_year <- dplyr::bind_rows(df_year, df)
#'       }
#'       if (!ok) {
#'         warning(sprintf("'%s' has no data at %s for %d; skipping file." , var, resolution, yr))
#'       } else {
#'         # save one CSV per variable-year
#'         fn <- file.path(output_dir, sprintf("%s_%s_%04d.csv", var, resolution, yr))
#'         write.csv2(df_year, fn, row.names=FALSE, quote=TRUE)
#'         if (verbose) message(" Saved ", basename(fn), " (", nrow(df_year), " rows)")
#'       }
#'       if (exists("df_year", inherits=FALSE)) rm(df_year)
#'     }
#'   }
#'   invisible(NULL)
#' }
#' 
#' 
#' #' @encoding UTF-8
#' #' @title esios2csv: Descargar series temporales de ESIOS y guardar como CSV por año
#' #'
#' #' @description
#' #' \code{esios2csv} descarga indicadores de ESIOS de España y escribe un único
#' #' archivo CSV por variable y año, combinando internamente fragmentos mensuales
#' #' para evitar timeouts en resoluciones finas. Si la consulta falla, emite un aviso
#' #' y continúa con la siguiente variable.
#' #'
#' #' @param var_names  Vector de caracteres con indicadores en formato "ShortName_ID"
#' #'   (p.ej. "Wind_551").
#' #' @param years      Vector entero de años a descargar (p.ej. 2020:2023).
#' #' @param api_key    Cadena con tu token de la API ESIOS.
#' #' @param resolution Carácter; granularidad de los datos: una de
#' #'   "1min", "5min", "10min", "15min", "30min", "1hour", "4hour", "1day".
#' #' @param output_dir Directorio destino para CSV (se crea si no existe).
#' #' @param verbose    Lógico; si \code{TRUE} muestra mensajes de progreso.
#' #' @param encoding   Codificación JSON (por defecto "UTF-8").
#' #'
#' #' @details
#' #' Para resoluciones menores a "1day", la función:
#' #' 1. Divide cada año en ventanas de un mes para la consulta.
#' #' 2. Recupera datos mes a mes y los concatena.
#' #' 3. Verifica que los intervalos de tiempo corresponden a la granularidad solicitada.
#' #' Si no hay datos en la resolución pedida, emite un aviso y omite la variable.
#' #'
#' #' @return
#' #' Genera uno o más archivos CSV por variable y año con columnas:
#' #' * \code{instant}: Timestamp "YYYY-MM-DD HH:MM:SS" (Europe/Madrid).
#' #' * \code{val}: Valor numérico.
#' #' * \code{geocode}: Código geográfico (si existe).
#' #' * \code{geolabel}: Etiqueta geográfica (si existe).
#' #'
#' #' @examples
#' #' \dontrun{
#' #' api_key <- "TU_TOKEN"
#' #' esios2csv(
#' #'   var_names  = c("Wind_551", "Solar_PV_119"),
#' #'   years      = 2023,
#' #'   api_key    = api_key,
#' #'   resolution = "10min",
#' #'   output_dir = "./data_csv",
#' #'   verbose    = TRUE
#' #' )
#' #' }
#' #'
#' #' @importFrom httr GET add_headers timeout status_code content
#' #' @importFrom jsonlite fromJSON
#' #' @importFrom lubridate ymd_hms with_tz months days
#' #' @export
#' esios2csv <- function(var_names,
#'                       years,
#'                       api_key,
#'                       resolution = c("1min","5min","10min","15min","30min","1hour","4hour","1day"),
#'                       output_dir,
#'                       verbose = FALSE,
#'                       encoding = "UTF-8") {
#'   resolution <- match.arg(resolution)
#'   suffix_map <- c(
#'     "1min" = "1m", "5min" = "5m", "10min" = "10m",
#'     "15min" = "15m", "30min" = "30m", "1hour" = "1h",
#'     "4hour" = "4h", "1day" = "1d"
#'   )
#'   suffix <- suffix_map[resolution]
#'   if (!dir.exists(output_dir)) dir.create(output_dir, recursive = TRUE)
#'   
#'   to_iso_utc <- function(dt) {
#'     format(with_tz(dt, "UTC"), "%Y-%m-%dT%H:%M:%SZ")
#'   }
#'   
#'   # segundos esperados por resolución
#'   exp_secs <- c(
#'     "1min" = 60,
#'     "5min" = 5*60,
#'     "10min" = 10*60,
#'     "15min" = 15*60,
#'     "30min" = 30*60,
#'     "1hour" = 3600,
#'     "4hour" = 4*3600,
#'     "1day" = 24*3600
#'   )
#'   
#'   for (var in var_names) {
#'     var_id <- as.integer(sub(".*_(\\d+)$", "\\1", var))
#'     for (yr in years) {
#'       all_chunks <- vector("list", 12)
#'       for (m in 1:12) {
#'         start_dt <- as.POSIXct(sprintf("%04d-%02d-01 00:00:00", yr, m), tz="Europe/Madrid")
#'         last_day <- as.integer(format(start_dt %m+% months(1) - days(1), "%d"))
#'         end_dt <- as.POSIXct(sprintf("%04d-%02d-%02d 23:59:59", yr, m, last_day), tz="Europe/Madrid")
#'         
#'         time_trunc <- switch(resolution,
#'                              "1min"  = "minute",
#'                              "5min"  = "five_minutes",
#'                              "10min" = "ten_minutes",
#'                              "15min" = "fifteen_minutes",
#'                              "30min" = "thirty_minutes",
#'                              "1hour" = "hour",
#'                              "4hour" = "four_hours",
#'                              "1day"  = "day"
#'         )
#'         if (verbose) message(sprintf("ID=%d @ %s: %04d-%02d", var_id, resolution, yr, m))
#'         res <- httr::GET(
#'           sprintf(
#'             "https://api.esios.ree.es/indicators/%d?start_date=%s&end_date=%s&time_trunc=%s&locale=es",
#'             var_id, to_iso_utc(start_dt), to_iso_utc(end_dt), time_trunc
#'           ),
#'           httr::add_headers(
#'             Accept = "application/json; application/vnd.esios-api-v1+json",
#'             `x-api-key` = api_key
#'           ),
#'           httr::timeout(120)
#'         )
#'         if (httr::status_code(res) != 200) next
#'         cont <- suppressWarnings(httr::content(res, "text", encoding = encoding))
#'         df_raw <- suppressMessages(jsonlite::fromJSON(cont, simplifyDataFrame=TRUE))$indicator$values
#'         if (is.null(df_raw) || nrow(df_raw)==0) next
#'         df <- as.data.frame(df_raw, stringsAsFactors=FALSE)
#'         if (!"datetime" %in% names(df) && "date" %in% names(df)) {
#'           df$datetime <- paste0(df$date, "T00:00:00Z")
#'         }
#'         idx <- grepl("^\\d{4}-\\d{2}-\\d{2}$", df$datetime)
#'         df$datetime[idx] <- paste0(df$datetime[idx], "T00:00:00Z")
#'         tm <- lubridate::ymd_hms(df$datetime, tz="UTC") |> with_tz("Europe/Madrid")
#'         diffs <- as.numeric(diff(sort(unique(tm))), units="secs")
#'         expected <- exp_secs[resolution]
#'         if (length(diffs)==0 || !any(abs(diffs - expected) < 1e-6)) next
#'         all_chunks[[m]] <- data.frame(
#'           instant = format(tm, "%Y-%m-%d %H:%M:%S"),
#'           val     = df$value,
#'           geocode = if ("geocode" %in% names(df)) df$geocode else NA_integer_,
#'           geolabel= if ("geolabel"%in% names(df)) df$geolabel else NA_character_,
#'           stringsAsFactors=FALSE
#'         )
#'       }
#'       dat_year <- do.call(rbind, all_chunks)
#'       if (is.null(dat_year) || nrow(dat_year)==0) {
#'         warning(sprintf("'%s' no tiene datos %s en %d", var, resolution, yr))
#'         next
#'       }
#'       fn <- file.path(output_dir, sprintf("%s_%s_%04d.csv", var, suffix, yr))
#'       write.csv2(dat_year, fn, row.names=FALSE, quote=TRUE)
#'       if (verbose) message(sprintf("Guardado %s (%d filas)", basename(fn), nrow(dat_year)))
#'     }
#'   }
#' }
#' 
#' 
#' #' @title Download ESIOS time-series and save as CSV (chunked by month)
#' #'
#' #' @description
#' #' \code{esios2csv} descarga indicadores de ESIOS y escribe archivos CSV
#' #' (uno por variable y año), fragmentando las peticiones mes a mes para
#' #' evitar timeouts en resoluciones finas.
#' #'
#' #' @param var_names  Character vector de indicadores en formato
#' #'   \code{"ShortName_ID"} (p. ej. \code{"Wind_551"]).
#' #' @param years      Integer vector de años a descargar (p. ej. \code{2020:2023}).
#' #' @param api_key    Cadena con tu token personal de la API ESIOS.
#' #' @param resolution Character; granularidad de los datos. Debe ser uno de:
#' #'   \code{"1min"}, \code{"5min"}, \code{"10min"}, \code{"15min"},
#' #'   \code{"30min"}, \code{"1hour"}, \code{"4hour"}, \code{"1day"}.
#' #' @param output_dir Directorio donde se guardarán los CSV (se crea si no existe).
#' #' @param verbose    Lógico; si \code{TRUE} muestra mensajes de progreso.
#' #' @param encoding   Codificación para leer el JSON (por defecto \code{"UTF-8"}).
#' #'
#' #' @details
#' #' Para resoluciones menores que \code{"1day"}, la función:
#' #' 1. Divide cada año en ventanas de un mes para no superar el timeout.
#' #' 2. Llama a la API de ESIOS mes a mes.
#' #' 3. Junta los fragmentos y comprueba que la diferencia de tiempo entre
#' #'    sucesivos \code{datetime} coincide exactamente con la granularidad
#' #'    solicitada (en segundos).
#' #'
#' #' Además, envolvemos la lectura JSON en \code{suppressMessages()} para
#' #' eliminar el aviso _"No encoding supplied: defaulting to UTF-8."_.
#' #'
#' #' @return
#' #' Archivos CSV con columnas:
#' #'   \describe{
#' #'     \item{instant}{Timestamp en \code{"YYYY-MM-DD HH:MM:SS"} (Europe/Madrid)}
#' #'     \item{val}{Valor numérico}
#' #'     \item{geocode}{Código geográfico (si existe)}
#' #'     \item{geolabel}{Etiqueta geográfica (si existe)}
#' #'   }
#' #'
#' #' @examples
#' #' \dontrun{
#' #' api_key <- "TU_TOKEN"
#' #' esios2csv(
#' #'   var_names  = c("Wind_551", "Solar_PV_119"),
#' #'   years      = 2023,
#' #'   api_key    = api_key,
#' #'   resolution = "10min",
#' #'   output_dir = "./data_csv",
#' #'   verbose    = TRUE
#' #' )
#' #' }
#' #'
#' #' @importFrom httr GET add_headers timeout status_code content
#' #' @importFrom jsonlite fromJSON
#' #' @importFrom lubridate ymd_hms with_tz
#' #' @export
#' esios2csv <- function(var_names,
#'                       years,
#'                       api_key,
#'                       resolution = c("1min","5min","10min","15min","30min","1hour","4hour","1day"),
#'                       output_dir,
#'                       verbose = FALSE,
#'                       encoding = "UTF-8") {
#'   resolution <- match.arg(resolution)
#'   # suffix for filenames
#'   suffix_map <- c(
#'     "1min" = "1m", "5min" = "5m", "10min" = "10m",
#'     "15min" = "15m", "30min" = "30m", "1hour" = "1h",
#'     "4hour" = "4h", "1day" = "1d"
#'   )
#'   suffix <- suffix_map[resolution]
#'   if (!dir.exists(output_dir)) dir.create(output_dir, recursive = TRUE)
#'   
#'   to_iso_utc <- function(dt) {
#'     format(lubridate::with_tz(dt, "UTC"), "%Y-%m-%dT%H:%M:%SZ")
#'   }
#'   
#'   # Split each year into monthly windows
#'   for (var in var_names) {
#'     var_id <- as.integer(sub(".*_(\\d+)$", "\\1", var))
#'     for (yr in years) {
#'       for (m in 1:12) {
#'         start_dt <- as.POSIXct(sprintf("%04d-%02d-01 00:00:00", yr, m), tz = "Europe/Madrid")
#'         end_dt <- as.POSIXct(sprintf("%04d-%02d-%02d 23:59:59", yr, m,
#'                                      as.integer(format(start_dt + months(1) - days(1), "%d"))), tz = "Europe/Madrid")
#'         
#'         # fetch
#'         time_trunc <- switch(resolution,
#'                              "1min" = "minute", "5min" = "five_minutes", "10min" = "ten_minutes",
#'                              "15min" = "fifteen_minutes", "30min" = "thirty_minutes",
#'                              "1hour" = "hour", "4hour" = "four_hours", "1day" = "day"
#'         )
#'         res <- httr::GET(
#'           sprintf("https://api.esios.ree.es/indicators/%d?start_date=%s&end_date=%s&time_trunc=%s&locale=es",
#'                   var_id, to_iso_utc(start_dt), to_iso_utc(end_dt), time_trunc),
#'           httr::add_headers(
#'             Accept = "application/json; application/vnd.esios-api-v1+json",
#'             `x-api-key` = api_key
#'           ),
#'           httr::timeout(120)
#'         )
#'         if (httr::status_code(res) != 200) next
#'         
#'         cont <- httr::content(res, "text", encoding = encoding)
#'         df_raw <- suppressMessages(jsonlite::fromJSON(cont, simplifyDataFrame = TRUE))$indicator$values
#'         df_raw <- as.data.frame(df_raw, stringsAsFactors = FALSE)
#'         if (!"datetime" %in% names(df_raw) && "date" %in% names(df_raw)) {
#'           df_raw$datetime <- paste0(df_raw$date, "T00:00:00Z")
#'         }
#'         iso_idx <- grepl("^\\d{4}-\\d{2}-\\d{2}$", df_raw$datetime)
#'         df_raw$datetime[iso_idx] <- paste0(df_raw$datetime[iso_idx], "T00:00:00Z")
#'         tm <- lubridate::ymd_hms(df_raw$datetime, tz = "UTC") |> with_tz("Europe/Madrid")
#'         # validate resolution
#'         diffs <- as.numeric(diff(sort(unique(tm))), units = "secs")
#'         expected <- switch(resolution,
#'                            "1min" = 60, "5min" = 5*60, "10min" = 10*60,
#'                            "15min" = 15*60, "30min" = 30*60, "1hour" = 3600,
#'                            "4hour" = 4*3600, "1day" = 86400
#'         )
#'         if (length(diffs)==0 || !any(abs(diffs - expected) < 1e-6)) next
#'         
#'         df_out <- data.frame(
#'           instant = format(tm, "%Y-%m-%d %H:%M:%S"),
#'           val      = df_raw$value,
#'           geocode  = if ("geocode" %in% names(df_raw)) df_raw$geocode else NA_integer_,
#'           geolabel = if ("geolabel" %in% names(df_raw)) df_raw$geolabel else NA_character_,
#'           stringsAsFactors = FALSE
#'         )
#'         fn <- file.path(output_dir, sprintf("%s_%s_%04d%02d.csv", var, suffix, yr, m))
#'         write.csv2(df_out, fn, row.names = FALSE, quote = TRUE)
#'       }
#'     }
#'   }
#' }
#' 
#' 

#' #' @export
#' esios2csv <- function(var_names,
#'                       years,
#'                       api_key,
#'                       resolution = c("1min","5min","10min","15min","30min","1hour","4hour","1day"),
#'                       output_dir,
#'                       verbose = FALSE,
#'                       encoding = "UTF-8") {
#'   resolution <- match.arg(resolution)
#'   tz <- "Europe/Madrid"
#'   # Mapa trunc y segundos esperados
#'   trunc_map <- c(
#'     "1min"  = "minute",       "5min"  = "five_minutes",
#'     "10min" = "ten_minutes",  "15min" = "fifteen_minutes",
#'     "30min" = "thirty_minutes","1hour" = "hour",
#'     "4hour" = "four_hours",   "1day"  = "day"
#'   )
#'   exp_secs <- c(
#'     "1min"  =  60,    "5min"  =  5*60,
#'     "10min" = 10*60,  "15min" = 15*60,
#'     "30min" = 30*60,  "1hour" = 3600,
#'     "4hour" = 4*3600, "1day"  = 24*3600
#'   )
#'   suffix <- resolution
#'   if (!dir.exists(output_dir)) dir.create(output_dir, recursive = TRUE)
#'   
#'   to_iso_utc <- function(dt) format(lubridate::with_tz(dt, "UTC"), "%Y-%m-%dT%H:%M:%SZ")
#'   
#'   fetch_chunk <- function(var_id, s, e) {
#'     httr::GET(
#'       sprintf("https://api.esios.ree.es/indicators/%d?start_date=%s&end_date=%s&time_trunc=%s&locale=es",
#'               var_id, to_iso_utc(s), to_iso_utc(e), trunc_map[[resolution]]),
#'       httr::add_headers(
#'         Accept      = "application/json; application/vnd.esios-api-v1+json",
#'         `x-api-key` = api_key
#'       ),
#'       httr::timeout(60)
#'     )
#'   }
#'   
#'   for (var_name in var_names) {
#'     if (!grepl("_\\d+$", var_name))
#'       stop("Formato incorrecto: debe ser 'ShortName_ID'")
#'     var_id <- as.integer(sub(".*_(\\d+)$", "\\1", var_name))
#'     
#'     for (yr in years) {
#'       if (verbose) message("→ ", var_name, "@", resolution, " — año ", yr)
#'       saved <- character()
#'       ok_all <- TRUE
#'       
#'       # Para resoluciones finas: recorremos mes a mes
#'       bounds <- seq(
#'         as.Date(paste0(yr,"-01-01")), as.Date(paste0(yr,"-12-31")),
#'         by="month"
#'       )
#'       bounds <- c(bounds, as.Date(paste0(yr,"-12-31")) + 1)
#'       
#'       df_all <- NULL
#'       for (j in seq_along(bounds)[-length(bounds)]) {
#'         s <- as.POSIXct(paste0(bounds[j],   " 00:00:00"), tz=tz)
#'         e <- as.POSIXct(paste0(bounds[j+1], " 00:00:00"), tz=tz) - 1
#'         res <- fetch_chunk(var_id, s, e)
#'         code <- httr::status_code(res)
#'         if (code != 200) {
#'           warning(sprintf("  HTTP %d para %s mes %s; salto.", code, var_name, bounds[j]))
#'           ok_all <- FALSE
#'           break
#'         }
#'         part <- jsonlite::fromJSON(httr::content(res,"text",encoding), simplifyDataFrame=TRUE)$indicator$values
#'         if (length(part)>0)
#'           df_all <- dplyr::bind_rows(df_all, part)
#'       }
#'       if (!ok_all || is.null(df_all) || nrow(df_all)==0) next
#'       
#'       df_raw <- as.data.frame(df_all, stringsAsFactors=FALSE)
#'       if (!"datetime"%in%names(df_raw) && "date"%in%names(df_raw))
#'         df_raw$datetime <- paste0(df_raw$date,"T00:00:00Z")
#'       iso <- grepl("^\\d{4}-\\d{2}-\\d{2}$", df_raw$datetime)
#'       df_raw$datetime[iso] <- paste0(df_raw$datetime[iso],"T00:00:00Z")
#'       
#'       tm <- lubridate::ymd_hms(df_raw$datetime,tz="UTC") %>% lubridate::with_tz(tz)
#'       diffs <- as.numeric(diff(sort(unique(tm))), units="secs")
#'       if (length(diffs)==0 || !all(abs(diffs - exp_secs[[resolution]])<1e-6)) {
#'         warning(sprintf("  %s no tiene datos a %s en %d; salto.", var_name, resolution, yr))
#'         next
#'       }
#'       
#'       df_out <- data.frame(
#'         instant  = format(tm, "%Y-%m-%d %H:%M:%S"),
#'         val      = df_raw$value,
#'         geocode  = if ("geocode"%in%names(df_raw)) df_raw$geocode else NA_integer_,
#'         geolabel = if ("geolabel"%in%names(df_raw)) df_raw$geolabel else NA_character_,
#'         stringsAsFactors = FALSE
#'       )
#'       fn <- file.path(output_dir, sprintf("%s_%s%04d.csv", var_name, suffix, yr))
#'       write.csv2(df_out, fn, row.names=FALSE, quote=TRUE)
#'       if (verbose) message("   ✔ ", basename(fn), " (", nrow(df_out)," filas)")
#'     }
#'   }
#' }


#' #' @export
#' esios2csv <- function(var_names,
#'                       years,
#'                       api_key,
#'                       resolution = c("1min","5min","10min","15min","30min","1hour","4hour","1day"),
#'                       output_dir,
#'                       verbose = FALSE,
#'                       encoding = "UTF-8") {
#'   
#'   resolution <- match.arg(resolution)
#'   tz         <- "Europe/Madrid"
#'   
#'   trunc_map <- list(
#'     "1min"  = "minute",       "5min"  = "five_minutes",
#'     "10min" = "ten_minutes",  "15min" = "fifteen_minutes",
#'     "30min" = "thirty_minutes","1hour" = "hour",
#'     "4hour" = "four_hours",   "1day"  = "day"
#'   )
#'   exp_secs <- c(
#'     "1min"  =  60,    "5min"  =  5*60,
#'     "10min" = 10*60,  "15min" = 15*60,
#'     "30min" = 30*60,  "1hour" = 3600,
#'     "4hour" = 4*3600, "1day"  = 24*3600
#'   )
#'   suffix <- resolution
#'   
#'   if (!dir.exists(output_dir)) dir.create(output_dir, recursive = TRUE)
#'   to_iso_utc <- function(dt) format(lubridate::with_tz(dt, "UTC"), "%Y-%m-%dT%H:%M:%SZ")
#'   
#'   fetch_range <- function(var_id, s, e, time_trunc) {
#'     httr::GET(
#'       sprintf("https://api.esios.ree.es/indicators/%d?start_date=%s&end_date=%s&time_trunc=%s&locale=es",
#'               var_id, to_iso_utc(s), to_iso_utc(e), time_trunc),
#'       httr::add_headers(
#'         Accept         = "application/json; application/vnd.esios-api-v1+json",
#'         `Content-Type` = "application/json",
#'         `x-api-key`    = api_key
#'       ),
#'       httr::timeout(120)
#'     )
#'   }
#'   
#'   for (var_name in var_names) {
#'     if (!grepl("_\\d+$", var_name))
#'       stop(sprintf("'%s' must follow '<short_name>_<id>' format.", var_name))
#'     var_id <- as.integer(sub(".*_(\\d+)$", "\\1", var_name))
#'     
#'     for (yr in years) {
#'       if (verbose)
#'         message(sprintf("Processing %s (ID=%d) for %d @ %s...", var_name, var_id, yr, resolution))
#'       
#'       start_dt <- lubridate::ymd(sprintf("%d-01-01", yr), tz = tz)
#'       end_dt   <- as.POSIXct(sprintf("%d-12-31 23:59:59", yr), tz = tz)
#'       
#'       res <- fetch_range(var_id, start_dt, end_dt, trunc_map[[resolution]])
#'       code <- httr::status_code(res)
#'       
#'       # split on 504, but skip on any other error
#'       if (code == 504) {
#'         mid <- start_dt + (end_dt - start_dt)/2
#'         if (verbose) message("  HTTP 504: splitting request...")
#'         r1 <- fetch_range(var_id, start_dt, mid, trunc_map[[resolution]])
#'         r2 <- fetch_range(var_id, mid+1, end_dt, trunc_map[[resolution]])
#'         if (!all(httr::status_code(r1)==200, httr::status_code(r2)==200)) {
#'           warning(sprintf("'%s' @ %d: error splitting ranges, skipping.", var_name, yr))
#'           break
#'         }
#'         p1 <- jsonlite::fromJSON(httr::content(r1,"text",encoding), simplifyDataFrame=TRUE)
#'         p2 <- jsonlite::fromJSON(httr::content(r2,"text",encoding), simplifyDataFrame=TRUE)
#'         df_raw <- dplyr::bind_rows(p1$indicator$values, p2$indicator$values)
#'       } else if (code == 200) {
#'         p      <- jsonlite::fromJSON(httr::content(res,"text",encoding), simplifyDataFrame=TRUE)
#'         df_raw <- p$indicator$values
#'       } else {
#'         warning(sprintf("HTTP %d for %s @ %d; skipping this variable.", code, var_name, yr))
#'         break
#'       }
#'       
#'       df_raw <- as.data.frame(df_raw, stringsAsFactors = FALSE)
#'       if (!"datetime"%in%names(df_raw) && "date"%in%names(df_raw))
#'         df_raw$datetime <- paste0(df_raw$date,"T00:00:00Z")
#'       iso_idx <- grepl("^\\d{4}-\\d{2}-\\d{2}$", df_raw$datetime)
#'       df_raw$datetime[iso_idx] <- paste0(df_raw$datetime[iso_idx],"T00:00:00Z")
#'       
#'       tm <- lubridate::ymd_hms(df_raw$datetime, tz="UTC") %>% lubridate::with_tz(tz)
#'       diffs <- as.numeric(diff(sort(unique(tm))), units="secs")
#'       if (length(diffs)==0 || !all(abs(diffs - exp_secs[[resolution]])<1e-6)) {
#'         warning(sprintf("'%s' has no %s data for %d; skipping.", var_name, resolution, yr))
#'         next
#'       }
#'       
#'       df_out <- data.frame(
#'         instant  = format(tm, "%Y-%m-%d %H:%M:%S"),
#'         val      = df_raw$value,
#'         geocode  = if ("geocode" %in% names(df_raw)) df_raw$geocode else NA_integer_,
#'         geolabel = if ("geolabel"%in% names(df_raw)) df_raw$geolabel else NA_character_,
#'         stringsAsFactors = FALSE
#'       )
#'       
#'       fn <- file.path(output_dir, sprintf("%s_%s%04d.csv", var_name, suffix, yr))
#'       write.csv2(df_out, fn, row.names=FALSE, quote=TRUE)
#'       if (verbose) message("  saved ", basename(fn), " (", nrow(df_out), " rows)")
#'     }
#'   }
#' }
#' 
#' 
#' 
#' #' @title Download ESIOS time-series and save as CSV
#' #'
#' #' @description
#' #' \code{esios2csv} retrieves raw ESIOS indicators from Spain's API and writes
#' #' individual CSV files per variable and year, named <var_name>_<resolution><year>.csv.
#' #' It enforces the \code{instant} column to use the format "YYYY-MM-DD HH:MM:SS"
#' #' in the Europe/Madrid timezone and manages large requests by splitting intervals
#' #' on HTTP 504 responses.
#' #'
#' #' @param var_names  Character vector of indicators in "ShortName_ID" format
#' #' @param years      Integer vector of years to download
#' #' @param api_key    Your ESIOS API key
#' #' @param resolution One of "1min","5min","10min","15min","30min","1hour","4hour","1day"
#' #' @param output_dir Directory where CSV files will be saved
#' #' @param verbose    Logical; if TRUE prints progress messages
#' #' @param encoding   JSON encoding (default "UTF-8")
#' #'
#' #' @export
#' esios2csv <- function(var_names,
#'                       years,
#'                       api_key,
#'                       resolution = c("1min","5min","10min","15min","30min","1hour","4hour","1day"),
#'                       output_dir,
#'                       verbose = FALSE,
#'                       encoding = "UTF-8") {
#'   
#'   resolution <- match.arg(resolution)
#'   tz         <- "Europe/Madrid"
#'   
#'   # map resolution to API time_trunc and expected seconds
#'   trunc_map <- list(
#'     "1min"  = "minute",
#'     "5min"  = "five_minutes",
#'     "10min" = "ten_minutes",
#'     "15min" = "fifteen_minutes",
#'     "30min" = "thirty_minutes",
#'     "1hour" = "hour",
#'     "4hour" = "four_hours",
#'     "1day"  = "day"
#'   )
#'   exp_secs <- c(
#'     "1min"  =  60,
#'     "5min"  =  5*60,
#'     "10min" = 10*60,
#'     "15min" = 15*60,
#'     "30min" = 30*60,
#'     "1hour" = 3600,
#'     "4hour" = 4*3600,
#'     "1day"  = 24*3600
#'   )
#'   suffix <- resolution
#'   
#'   # ensure output directory exists
#'   if (!dir.exists(output_dir)) dir.create(output_dir, recursive = TRUE)
#'   
#'   # helper to format UTC for API
#'   to_iso_utc <- function(dt) {
#'     format(lubridate::with_tz(dt, "UTC"), "%Y-%m-%dT%H:%M:%SZ")
#'   }
#'   
#'   fetch_range <- function(var_id, s, e, time_trunc) {
#'     httr::GET(
#'       sprintf("https://api.esios.ree.es/indicators/%d?start_date=%s&end_date=%s&time_trunc=%s&locale=es",
#'               var_id, to_iso_utc(s), to_iso_utc(e), time_trunc),
#'       httr::add_headers(
#'         Accept         = "application/json; application/vnd.esios-api-v1+json",
#'         `Content-Type` = "application/json",
#'         `x-api-key`    = api_key
#'       ),
#'       httr::timeout(120)
#'     )
#'   }
#'   
#'   for (var_name in var_names) {
#'     if (!grepl("_\\d+$", var_name))
#'       stop(sprintf("'%s' must follow '<short_name>_<id>' format.", var_name))
#'     var_id <- as.integer(sub(".*_(\\d+)$", "\\1", var_name))
#'     
#'     for (yr in years) {
#'       if (verbose)
#'         message(sprintf("Processing %s (ID=%d) for %d @ %s...", var_name, var_id, yr, resolution))
#'       
#'       start_dt <- lubridate::ymd(sprintf("%d-01-01", yr), tz = tz)
#'       end_dt   <- as.POSIXct(sprintf("%d-12-31 23:59:59", yr), tz = tz)
#'       
#'       # attempt download
#'       resp <- fetch_range(var_id, start_dt, end_dt, trunc_map[[resolution]])
#'       if (httr::status_code(resp)==504) {
#'         mid <- start_dt + (end_dt - start_dt)/2
#'         if (verbose) message("  HTTP 504: splitting request...")
#'         r1 <- fetch_range(var_id, start_dt, mid, trunc_map[[resolution]])
#'         r2 <- fetch_range(var_id, mid+1, end_dt, trunc_map[[resolution]])
#'         stopifnot(httr::status_code(r1)==200, httr::status_code(r2)==200)
#'         p1 <- jsonlite::fromJSON(httr::content(r1,"text",encoding), simplifyDataFrame=TRUE)
#'         p2 <- jsonlite::fromJSON(httr::content(r2,"text",encoding), simplifyDataFrame=TRUE)
#'         df_raw <- dplyr::bind_rows(p1$indicator$values, p2$indicator$values)
#'       } else if (httr::status_code(resp)==200) {
#'         p      <- jsonlite::fromJSON(httr::content(resp,"text",encoding), simplifyDataFrame=TRUE)
#'         df_raw <- p$indicator$values
#'       } else {
#'         stop(sprintf("HTTP %d for %s @ %d", httr::status_code(resp), var_name, yr))
#'       }
#'       
#'       df_raw <- as.data.frame(df_raw, stringsAsFactors = FALSE)
#'       if (!"datetime"%in%names(df_raw) && "date"%in%names(df_raw))
#'         df_raw$datetime <- paste0(df_raw$date,"T00:00:00Z")
#'       iso_idx <- grepl("^\\d{4}-\\d{2}-\\d{2}$", df_raw$datetime)
#'       df_raw$datetime[iso_idx] <- paste0(df_raw$datetime[iso_idx],"T00:00:00Z")
#'       
#'       # parse timestamps to Europe/Madrid
#'       tm <- lubridate::ymd_hms(df_raw$datetime, tz="UTC") %>% lubridate::with_tz(tz)
#'       
#'       # validate resolution
#'       diffs <- as.numeric(diff(sort(unique(tm))), units="secs")
#'       if (length(diffs)==0 || !all(abs(diffs - exp_secs[[resolution]])<1e-6)) {
#'         warning(sprintf("'%s' has no %s data for year %d; skipping.", var_name, resolution, yr))
#'         next
#'       }
#'       
#'       # prepare output
#'       df_out <- data.frame(
#'         instant  = format(tm, "%Y-%m-%d %H:%M:%S"),
#'         val      = df_raw$value,
#'         geocode  = if ("geocode" %in% names(df_raw)) df_raw$geocode else NA_integer_,
#'         geolabel = if ("geolabel"%in% names(df_raw)) df_raw$geolabel else NA_character_,
#'         stringsAsFactors = FALSE
#'       )
#'       
#'       fn <- file.path(output_dir, sprintf("%s_%s%04d.csv", var_name, suffix, yr))
#'       write.csv2(df_out, fn, row.names=FALSE, quote=TRUE)
#'       if (verbose) message("  saved ", basename(fn), " (", nrow(df_out), " rows)")
#'     }
#'   }
#' }


#' #' @title Download ESIOS time-series and save as CSV
#' #'
#' #' @description
#' #' \code{esios2csv} retrieves raw ESIOS indicators from Spain's API and writes
#' #' individual CSV files per variable and year, named <var_name><suffix><year>.csv.
#' #' It enforces the \code{instant} column to use the format "YYYY-MM-DD HH:MM:SS"
#' #' in the Europe/Madrid timezone and manages large requests by splitting intervals
#' #' on HTTP 504 responses.
#' #'
#' #' @param var_names Character vector of indicators in "ShortName_ID" format,
#' #'   e.g. \code{c("Wind_551", "Solar_PV_119")}. The ID is extracted automatically.
#' #' @param years Integer vector of years to download, e.g. \code{2023:2024}.
#' #' @param api_key String: your ESIOS API key.
#' #' @param resolution Character: \code{"hour"} (hourly) or \code{"min"} (10-minute).
#' #' @param output_dir Directory where CSV files will be saved (created if needed).
#' #' @param verbose Logical (default FALSE). If TRUE, prints progress messages in English.
#' #' @param encoding Encoding used to read the JSON (default "UTF-8").
#' #'
#' #' @details
#' #' These functions call the ESIOS API directly. Per the ESIOS API usage guidelines,
#' #' **you must supply a personal API token** (request it at https://www.esios.ree.es/en/page/api)
#' #' and **use it responsibly**:
#' #' * Cache API responses on your own server if exposing public applications.
#' #' * Avoid redundant or unnecessary requests (e.g., re-requesting data you already have).
#' #'   See the official terms at https://api.esios.ree.es for more information.
#' #'
#' #' @examples
#' #' \dontrun{
#' #' api_key <- "YOUR_API_KEY"
#' #' esios2csv(
#' #'   var_names  = c("Wind_551", "Solar_PV_119"),
#' #'   years      = 2023:2024,
#' #'   api_key    = api_key,
#' #'   resolution = "hour",
#' #'   output_dir = "./data_csv",
#' #'   verbose    = TRUE
#' #' )
#' #' }
#' #'
#' #' @export
#' esios2csv <- function(var_names,
#'                       years,
#'                       api_key,
#'                       resolution = c("hour", "min"),
#'                       output_dir,
#'                       verbose = FALSE,
#'                       encoding = "UTF-8") {
#'   resolution <- match.arg(resolution)
#'   suffix     <- if (resolution == "min") "m" else "h"
#'   if (!dir.exists(output_dir)) dir.create(output_dir, recursive = TRUE)
#'   
#'   # Helper to format datetime in ISO UTC
#'   to_iso_utc <- function(dt) {
#'     format(with_tz(dt, "UTC"), "%Y-%m-%dT%H:%M:%SZ")
#'   }
#'   
#'   for (var_name in var_names) {
#'     if (!grepl("_\\d+$", var_name)) {
#'       stop(sprintf("'%s' must follow '<short_name>_<id>' format.", var_name))
#'     }
#'     var_id <- as.integer(sub(".*_(\\d+)$", "\\1", var_name))
#'     if (is.na(var_id)) stop(sprintf("Could not extract ID from '%s'.", var_name))
#'     
#'     resolution_ok <- TRUE
#'     saved_files   <- character(0)
#'     
#'     for (yr in years) {
#'       if (verbose) message(sprintf("Processing '%s' (ID=%d) for year %d...", var_name, var_id, yr))
#'       start_dt <- lubridate::ymd(sprintf("%d-01-01", yr), tz = "Europe/Madrid")
#'       end_dt   <- as.POSIXct(sprintf("%d-12-31 23:59:59", yr), tz = "Europe/Madrid")
#'       
#'       # Function to fetch a range, handling resolution parameter
#'       fetch_range <- function(s, e) {
#'         httr::GET(
#'           sprintf(
#'             "https://api.esios.ree.es/indicators/%d?start_date=%s&end_date=%s&time_trunc=%s&locale=es",
#'             var_id, to_iso_utc(s), to_iso_utc(e),
#'             if (resolution == "min") "ten_minutes" else "hour"
#'           ),
#'           httr::add_headers(
#'             Accept         = "application/json; application/vnd.esios-api-v1+json",
#'             `Content-Type` = "application/json",
#'             `x-api-key`    = api_key
#'           ),
#'           httr::timeout(120)
#'         )
#'       }
#'       
#'       # Attempt request, split on HTTP 504
#'       res <- fetch_range(start_dt, end_dt)
#'       if (httr::status_code(res) == 504) {
#'         mid <- start_dt + (end_dt - start_dt) / 2
#'         if (verbose) message("  Received HTTP 504; splitting request into two halves...")
#'         r1 <- fetch_range(start_dt, mid); stopifnot(httr::status_code(r1) == 200)
#'         r2 <- fetch_range(mid + seconds(1), end_dt); stopifnot(httr::status_code(r2) == 200)
#'         p1 <- jsonlite::fromJSON(httr::content(r1, "text", encoding = encoding))
#'         p2 <- jsonlite::fromJSON(httr::content(r2, "text", encoding = encoding))
#'         df_raw <- dplyr::bind_rows(p1$indicator$values, p2$indicator$values)
#'       } else if (httr::status_code(res) == 200) {
#'         p      <- jsonlite::fromJSON(httr::content(res, "text", encoding = encoding))
#'         df_raw <- p$indicator$values
#'       } else {
#'         stop(sprintf(
#'           "HTTP %d downloading '%s' for year %d", 
#'           httr::status_code(res), var_name, yr
#'         ))
#'       }
#'       df_raw <- as.data.frame(df_raw, stringsAsFactors = FALSE)
#'       
#'       # Ensure a datetime column in ISO format
#'       if (!"datetime" %in% names(df_raw) && "date" %in% names(df_raw)) {
#'         df_raw$datetime <- paste0(df_raw$date, "T00:00:00Z")
#'       }
#'       iso_idx <- grepl("^\\d{4}-\\d{2}-\\d{2}$", df_raw$datetime)
#'       df_raw$datetime[iso_idx] <- paste0(df_raw$datetime[iso_idx], "T00:00:00Z")
#'       
#'       # Parse timestamps to POSIXct in Europe/Madrid
#'       tm <- lubridate::ymd_hms(df_raw$datetime, tz = "UTC") %>% with_tz("Europe/Madrid")
#'       
#'       # Validate actual resolution
#'       if (resolution == "min") {
#'         diffs_sec <- as.numeric(diff(sort(unique(tm))), units = "secs")
#'         if (length(diffs_sec) == 0 || all(diffs_sec > 600)) {
#'           warning(sprintf(
#'             "Variable '%s' has no data at the requested resolution; skipping this variable.",
#'             var_name
#'           ))
#'           resolution_ok <- FALSE
#'           break
#'         }
#'       } else {
#'         if (any(lubridate::minute(tm) != 0 | lubridate::second(tm) != 0)) {
#'           warning(sprintf(
#'             "Variable '%s' has no data at the requested resolution; skipping this variable.",
#'             var_name
#'           ))
#'           resolution_ok <- FALSE
#'           break
#'         }
#'       }
#'       
#'       # Format and save this year's data
#'       df_out <- df_raw %>%
#'         dplyr::mutate(
#'           tm      = tm,
#'           instant = format(tm, "%Y-%m-%d %H:%M:%S")
#'         ) %>%
#'         dplyr::transmute(
#'           instant  = instant,
#'           val       = value,
#'           geocode   = if ("geocode"  %in% names(df_raw)) geocode  else NA_integer_,
#'           geolabel  = if ("geolabel" %in% names(df_raw)) geolabel else NA_character_
#'         )
#'       
#'       fn <- file.path(output_dir, sprintf("%s_%s%04d.csv", var_name, suffix, yr))
#'       write.csv2(df_out, fn, row.names = FALSE, quote = TRUE)
#'       saved_files <- c(saved_files, fn)
#'       if (verbose) message(sprintf("  Saved %s (%d rows)", basename(fn), nrow(df_out)))
#'     }
#'     
#'     # If resolution check failed, remove partial files and continue
#'     if (!resolution_ok) {
#'       file.remove(saved_files)
#'       next
#'     }
#'   }
#' }
