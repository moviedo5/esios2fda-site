#' @encoding UTF-8
#' @title Read ESIOS CSVs or RDAs and transform into functional-data (\code{fdata}) objects
#'
#' @description
#'   Reads ESIOS CSVs or RDA files produced by \code{esios2csv()} and converts them
#'   into functional-data (fdata) objects. Supports multiple resolutions (minute-based
#'   and hourly) and handles daylight-saving anomalies by interpolating missing or
#'   duplicate intervals at the DST transition.
#'
#' @param var_names   Character vector of variable names (e.g. "Solar_PV_119").
#' @param years       Integer vector of years to process.
#' @param resolution  Character: one of "1min","5min","10min","15min","30min","hour","1hour";
#'                    must match the resolution used when generating CSV/RDA.
#' @param input_dir   Directory containing CSV or RDA files.
#' @param output_dir  Directory where RDA files will be saved (created if missing);
#'                    if NULL, no output files are written.
#' @param mode        Character: "csv" to read CSV files, "rda" to read saved RDA objects.
#' @param verbose     Logical; if TRUE, prints progress messages.
#'
#' @return A list of class c("ldata","list") of \code{fdata} objects, named
#'         by "<var>_<suffix><year>".
#'
#' @importFrom utils read.csv2
#' @importFrom stats xtabs
#' @importFrom lubridate ymd_hms yday hour minute with_tz
#' @importFrom fda.usc fdata
#' @importFrom dplyr mutate transmute
#' @export
esios2fdata <- function(var_names, years,
                        resolution = c("1min","5min","10min","15min","30min","hour","1hour"),
                        input_dir, output_dir = NULL,
                        mode = c("csv","rda"), verbose = FALSE) {
  resolution <- match.arg(resolution)
  mode       <- match.arg(mode)
  tz         <- "Europe/Madrid"
  
  # Determine numeric minute and slot settings
  numeric_min <- if (resolution %in% c("hour","1hour")) 60 else as.numeric(sub("min", "", resolution))
  slots_per_hr <- 60 / numeric_min
  total_slots  <- if (numeric_min == 60) 24 else 24 * slots_per_hr
  # DST smoothing position: first slot of 02:00 local time
  pos_col <- if (numeric_min == 60) 3 else (2 * slots_per_hr + 1)
  
  # Smoothing function for DST anomalies
  smooth_mat <- function(mat) {
    ncol_mat <- ncol(mat)
    # insert missing columns
    while (ncol_mat < total_slots) {
      lo <- mat[, pos_col - 1]; hi <- mat[, pos_col]
      interp <- (lo + hi) / 2
      mat <- cbind(mat[, 1:(pos_col - 1), drop = FALSE], interp, mat[, pos_col:ncol_mat, drop = FALSE])
      ncol_mat <- ncol(mat)
    }
    # remove duplicated columns
    while (ncol_mat > total_slots) {
      mat[, pos_col] <- (mat[, pos_col] + mat[, pos_col + 1]) / 2
      mat <- mat[, - (pos_col + 1), drop = FALSE]
      ncol_mat <- ncol(mat)
    }
    mat
  }
  
  # Map resolution to file suffix
  suffix_map <- c(
    "1min"  = "1m",  "5min"  = "5m",  "10min" = "10m",
    "15min" = "15m", "30min" = "30m", "hour"  = "h",  "1hour" = "h"
  )
  suffix <- suffix_map[[resolution]]
  
  if (!is.null(output_dir) && !dir.exists(output_dir)) {
    dir.create(output_dir, recursive = TRUE)
  }
  
  out <- list()
  for (var in var_names) {
    if (verbose) message("Processing variable ", var)
    for (yr in years) {
      name_base <- sprintf("%s_%s%04d", var, suffix, yr)
      if (verbose) message(" Year ", yr)
      
      # Load raw data
      if (mode == "csv") {
        fpath <- file.path(input_dir, paste0(name_base, ".csv"))
        df_raw <- tryCatch(
          read.csv2(fpath, stringsAsFactors = FALSE),
          error = function(e) NULL
        )
        if (is.null(df_raw)) {
          warning("File not found: ", basename(fpath)); next
        }
        # Parse timestamp
        df_raw$time <- lubridate::ymd_hms(df_raw$instant, tz = tz)
        df_proc <- df_raw %>% mutate(
          yday    = yday(time),
          hour    = hour(time),
          minute  = minute(time),
          interval = if (numeric_min == 60) hour else (hour * slots_per_hr + minute / numeric_min + 1),
          value    = as.numeric(gsub(',', '.', val))
        )
      } else {
        # RDA mode
        rpath <- file.path(input_dir, paste0(name_base, ".rda"))
        e <- tryCatch(load(rpath), error = function(e) NULL)
        if (is.null(e)) { warning("File not found: ", basename(rpath)); next }
        fdobj <- get(e)
        dates <- seq(as.Date(sprintf("%04d-01-01", yr)), by = "day", length.out = nrow(fdobj$data))
        if (numeric_min == 60) {
          times <- unlist(lapply(dates, function(d) seq(as.POSIXct(paste(d, "00:00:00"), tz = tz),
                                                        by = "hour", length.out = 24)))
          df_proc <- data.frame(time = times, value = as.numeric(t(fdobj$data)))
          df_proc$yday <- yday(df_proc$time)
          df_proc$hour <- hour(df_proc$time)
        } else {
          times <- unlist(lapply(dates, function(d) seq(as.POSIXct(paste(d, "00:00:00"), tz = tz),
                                                        by = sprintf("%d mins", numeric_min), length.out = total_slots)))
          df_proc <- data.frame(time = times, value = as.numeric(t(fdobj$data)))
          df_proc$yday   <- yday(df_proc$time)
          df_proc$hour   <- hour(df_proc$time)
          df_proc$minute <- minute(df_proc$time)
          df_proc$interval <- (df_proc$hour * slots_per_hr) + (df_proc$minute / numeric_min) + 1
        }
      }
      
      # Build matrix: rows = day of year, cols = interval/hour
      if (numeric_min == 60) {
        mat <- xtabs(value ~ yday + hour, data = df_proc)
      } else {
        mat <- xtabs(value ~ yday + interval, data = df_proc)
      }
      
      # Smooth DST anomalies
      mat_sm <- smooth_mat(mat)
      
      # Create fdata object
      argvals <- if (numeric_min == 60) seq(0.5, 23.5, length.out = 24) else seq(0, total_slots - 1) / total_slots * 24
      fdobj <- fda.usc::fdata(mat_sm, argvals,
                              names = list(
                                main = var,
                                xlab = if (numeric_min == 60) "Hour" else paste(numeric_min, "min intervals"),
                                ylab = "Value"
                              ))
      
      # Save if requested
      if (!is.null(output_dir)) {
        save(fdobj, file = file.path(output_dir, paste0(name_base, ".rda")))
      }
      out[[name_base]] <- fdobj
    }
  }
  
  class(out) <- c("ldata", "list")
  invisible(out)
}
#' 
#' 
#' #' @title Read ESIOS CSVs or RDAs and transform into functional-data (\code{fdata}) objects
#' #' 
#' #' @description Read ESIOS CSVs or RDAs and transform into functional-data (fdata) objects,
#' #' handling daylight saving time anomalies by smoothing missing or duplicated intervals.
#' #'
#' #' @param var_names Character vector of variable names (e.g. "Solar_PV_119").
#' #' @param years Integer vector of years to process.
#' #' @param resolution "hour" or "min".
#' #' @param input_dir Directory with CSVs or RDAs.
#' #' @param output_dir Where to save generated RDAs; created if missing.
#' #' @param mode "csv" or "rda".
#' #' @param verbose Logical.
#' #' @return A list of class c("ldata","list") with \code{fdata} objects.
#' #' @importFrom utils read.csv2
#' #' @importFrom stats xtabs
#' #' @importFrom lubridate ymd_hms yday hour minute
#' #' @importFrom fda.usc fdata
#' #' @importFrom dplyr mutate
#' #' @export
#' esios2fdata <- function(var_names, years, resolution = c("hour","min"),
#'                         input_dir, output_dir = NULL, mode = c("csv","rda"), 
#'                         verbose=FALSE) {
#'   
#'   resolution <- match.arg(resolution)
#'   suffix     <- if(resolution=="min") "m" else "h"
#'   mode       <- match.arg(mode)
#'   if (!is.null(output_dir) && !dir.exists(output_dir)) {
#'     dir.create(output_dir, recursive = TRUE)
#'   }
#'   
#'   smooth_mat <- function(mat, target_cols) {
#'     n <- ncol(mat)
#'     pos <- if(resolution=="min") 13 else 3
#'     # insert columns if faltan
#'     while(n < target_cols) {
#'       lo <- mat[,pos-1]; hi <- mat[,pos]
#'       interp <- (lo + hi)/2
#'       mat <- cbind(mat[,1:(pos-1),drop=FALSE], interp, mat[,pos:ncol(mat),drop=FALSE])
#'       n <- ncol(mat)
#'     }
#'     # remove columns if sobran
#'     while(n > target_cols) {
#'       mat[,pos] <- (mat[,pos] + mat[,pos+1])/2
#'       mat <- mat[,-(pos+1), drop=FALSE]
#'       n <- ncol(mat)
#'     }
#'     mat
#'   }
#'   
#'   out <- list()
#'   for(var in var_names) {
#'     if(verbose) message("Processing ", var)
#'     for(yr in years) {
#'       if(verbose) message(" Year ", yr)
#'       name_base <- sprintf("%s_%s%04d", var, suffix, yr)
#'       
#'       ## 1) Lectura segura del fichero
#'       if(mode == "csv") {
#'         fpath <- file.path(input_dir, paste0(name_base, ".csv"))
#'         df_raw <- tryCatch(
#'           read.csv2(fpath, stringsAsFactors=FALSE),
#'           error = function(e) {
#'             warning(sprintf(
#'               "Variable '%s': file '%s' not found; skipping this year.",
#'               var, basename(fpath)
#'             ))
#'             return(NULL)
#'           }
#'         )
#'         if (is.null(df_raw)) next
#'         
#'         df <- df_raw %>%
#'           mutate(time = ymd_hms(
#'             ifelse(grepl("^\\d{2}/\\d{2}/\\d{4}", instant),
#'                    as.character(as.POSIXct(instant, format="%d/%m/%Y %H:%M", tz="Europe/Madrid")),
#'                    instant), tz="Europe/Madrid"))
#'         df_proc <- df %>% mutate(
#'           yday     = yday(time),
#'           hour     = hour(time),
#'           minute   = minute(time),
#'           interval = if(resolution=="min") hour*6 + minute/10 + 1 else hour,
#'           value    = as.numeric(gsub(",", ".", val))
#'         )
#'         
#'       } else {
#'         rpath <- file.path(input_dir, paste0(name_base, ".rda"))
#'         rdaload <- tryCatch(
#'           load(rpath),
#'           error = function(e) {
#'             warning(sprintf(
#'               "Variable '%s': file '%s' not found; skipping this year.",
#'               var, basename(rpath)
#'             ))
#'             return(NULL)
#'           }
#'         )
#'         if (is.null(rdaload)) next
#'         fd <- get(rdaload)
#'         dates <- seq(as.Date(sprintf("%04d-01-01", yr)), by="day", length.out=nrow(fd$data))
#'         if(resolution=="min") {
#'           times <- do.call(c, lapply(dates, function(d) seq(as.POSIXct(d), by="10 min", length.out=144)))
#'         } else {
#'           times <- do.call(c, lapply(dates, function(d) seq(as.POSIXct(d), by="1 hour", length.out=24)))
#'         }
#'         df_proc <- data.frame(time=times, value=as.numeric(t(fd$data))) %>%
#'           mutate(
#'             yday     = yday(time),
#'             hour     = hour(time),
#'             minute   = minute(time),
#'             interval = if(resolution=="min") hour*6 + minute/10 + 1 else hour
#'           )
#'       }
#'       
#'       ## 2) Construcción de la matriz
#'       if(resolution=="min") {
#'         mat <- xtabs(value ~ yday + interval, data=df_proc)
#'         target_cols <- 144
#'       } else {
#'         mat <- xtabs(value ~ yday + hour, data=df_proc)
#'         target_cols <- 24
#'       }
#'       
#'       ## 3) Suavizado DST
#'       mat_sm <- smooth_mat(mat, target_cols)
#'       
#'       ## 4) Creación de fdata
#'       argvals <- if(resolution=="min") seq(0, 143)/144*24 else seq(0.5, 23.5, length = 24)
#'       fdobj <- fda.usc::fdata(mat_sm, argvals,
#'                               names=list(main=var,
#'                                          xlab = if(resolution=="min") "10-min intervals" else "Hours",
#'                                          ylab = "MW"))
#'       
#'       ## 5) Guardado y almacenamiento
#'       if (!is.null(output_dir)) {
#'         save(fdobj, file = file.path(output_dir, paste0(name_base, ".rda")))
#'       }
#'       out[[name_base]] <- fdobj
#'     }
#'   }
#'   
#'   class(out) <- c("ldata","list")
#'   invisible(out)
#' }


